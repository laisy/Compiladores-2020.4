# Gramática BNF

# ----------------- Dados ------------------------------------------------------

<letter> ::=  "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"

<digito> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<num> ::= <digit> {<digit>}*

<boolean> ::= "True" | "False"

<type> ::= "int" | "bool"

<identifier> ::= <letter> (<letter> | <num>)* 

<op_boolean> ::= == | !=  | > | < | >= | <=

<op_aritmetic> ::= + | - | * | /

# ----------------- Variaveis ------------------------------------------------------

<declaration_var> ::= <type> <identifier> = <end_var>;

<end_var> ::= = <call_func> | <boolean> | <call_op> | <num> | <identifier>

# ----------------- Parametros ------------------------------------------------------

<params> ::= <type> <identifier> <params2> | <empty>

<params2> ::= , <params> | <empty>

# parametros para chamada de função pois não precisa passar o type
<params_call> ::= <identifier> <params_call2> | <empty>

<params_call2> ::= , <params_call>

# ----------------- Função ------------------------------------------------------

<declaration_func> ::= func <type> <identifier> (<params>) { <block> <return_statement>}

<call_func> ::= call func <identifier> (<params_call>);

# ----------------- Procedimento ------------------------------------------------------

<declaration_proc> ::= proc <identifier> (<params>) { <block> }

<call_proc> ::= call proc <identifier> (<params_call>);

# ----------------- Operações ------------------------------------------------------

<call_op> ::= <num> <op_aritmetic> <call_op2> | <identifier> <op_aritmetic> <call_op2>

<call_op2> ::= <num> <call_op4> | <identifier> <call_op4>

<call_op3> ::= <call_op2> | <num> 

<call_op4> ::= (<op_aritmetic> <call_op3>)* | <empty>

# ----------------- Start ------------------------------------------------------

<program> ::= program { <block> } end

# ----------------- Expression ------------------------------------------------------

<expression> ::= <identifier> <expression2> | <call_func> <expression2> | <num> <expression2>

<expression2> ::= <op_boolean> <expression3> | <empty>

<expression3> ::= <identifier> | <call_func> | <num>

# ----------------- Condicional ------------------------------------------------------

<if_statement> ::= if(<expression>){<block3>} <else_part> endif

<else_part> ::= else { <block3> } endelse | <empty>
 
<while_statement> ::= while(<expression>){<block2>}endwhile

# IF chamado somente dentro do while, pois dentro dele pode ter BREAK E CONTINUE (block2)
<if_statement2> ::= if(<expression>){<block2>} <else_part> endif

# ----------------- Incondicional ------------------------------------------------------

# somente pode está dentro de um WHILE, e no IF/ELSE dentro do WHILE
<unconditional_branch> ::= continue ; | break ;

# ----------------- Return ------------------------------------------------------

<return_statement> ::= return <return_statement2> ;

<return_statement2> ::= <call_func> | <identifier> | <num> | <boolean>

# ----------------- Print ------------------------------------------------------

<print_statement> ::= print (<params_print>) ;

<params_print> ::= <identifier> | <call_func> | <call_op> | <boolean> | <num>

# ----------------- Blocos ------------------------------------------------------

<block> ::= <declaration_var> | <declaration_func> | <declaration_proc> | <call_func> | <call_proc> | <print_statement> | <if_statement> | <while_statement> | <identifier> | <call_op> | <empty> 

# block2 é o bloco que contém break/continue que só pode ser chamado dentro de um while
<block2> ::= <declaration_var> | <call_proc> | <call_func> | <identifier> | <if_statement2> | <while_statement> | <unconditional_branch> | <call_op> | <print_statement> 

# block3 é o bloco do if/else, que não pode declarar função e procedimento dentro
<block3> ::= <declaration_var> | <call_proc> | <call_func> | <identifier> | <if_statement2> | <while_statement> | <call_op> | <print_statement> 